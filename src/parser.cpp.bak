#include <iostream>
#include <string>
#include <unordered_map>

#include "parser.h"
#include "ast_node.h"
#include "ast_integer.h"
#include "ast_double.h"
#include "ast_bin_expr.h"
#include "t_vals.h"
#include "tok_val_pair.h"
#include "lexer.h"

std::unordered_map<int, int> op_prec = {
	{'+', 10},
	{'-', 20},
	{'*', 30}
};

static TokValPair* token;

/*
int get_token_prec(Token token) {

}
*/

void Parser::UNIMPLEMENTED(){
	std::cout << "Not implemented yet" << std::endl;
}

ASTNode* Parser::parse_bin_expr() {
	ASTNode* lhs;

	switch (token->token_type){ // primary expressions
	case static_cast<int>(Token::tok_integer):
		//@@@ check to see if nullptr
		lhs = new ASTInteger(token->token_value->int_num_val);
		return parse_binop_rhs(0, lhs);

	case static_cast<int>(Token::tok_floating_point):
		lhs = new ASTDouble(token->token_value->double_num_val);
		return parse_binop_rhs(0, lhs);

	case '(':
		return parse_paren_expr();

	default:
		//@@@
		UNIMPLEMENTED();
		return nullptr;
	}
}

ASTNode* Parser::parse_binop_rhs(int expr_prec, ASTNode* lhs){
	ASTNode* rhs;
	// check to see if next token is a binary operator
	TokValPair* peeked_token = peek(iterator);
	char token_prec = op_prec[(peeked_token->token_type)];
	
	if (token_prec > expr_prec) {
		// we have a binary operator
		iterator++;
		token = get_token(iterator);

		if(token->token_type == static_cast<int>(Token::tok_integer)){
			rhs = new ASTInteger(token->token_value->int_num_val);
		}else if(token->token_type == '('){
			rhs = parse_paren_expr();
			//token = get_token(iterator);
		}

		return new ASTBinExpr(peeked_token->token_type, lhs, rhs);
	}
	return lhs;
}

ASTNode* Parser::parse_paren_expr(){
	token = get_token(iterator); // eat '('
	ASTNode* n = parse_bin_expr();

	if(get_token(iterator)->token_type != ')'){
		std::cerr << "Expected closing parenthesis" << std::endl;
		return nullptr;
	}

	return n;
}

ASTNode* Parser::parse_top_level_expr(){
	token = get_token(iterator);

	switch(token->token_type){
		case static_cast<int>(Token::tok_def):
			UNIMPLEMENTED();
			return nullptr;

		case static_cast<int>(Token::tok_extern):
			UNIMPLEMENTED();
			return nullptr;

		case static_cast<int>(Token::tok_eof):
			return nullptr;

		default: // number or identifier
			ASTNode* n = nullptr;
			
			int peeked_token = peek(iterator)->token_type;
			switch (peeked_token) {
			case '+':
				n = parse_bin_expr();
			}
	}
}
